<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Document</title>
  </head>
  <body></body>
  <script>
    /**
     * 2023-03-25 javascript study
     * 객체 (object)
     */

    // 객체의 복사
    const obj = { a: 1, b: 2, c: 3 };
    const copy = obj; // { a: 1, b: 2, c: 3 }

    copy.b = 20; // { a: 1, b: 20, c: 3 }

    // 원본 객체가 같이 변경됨
    console.log("obj", obj);
    console.log("copy", copy);

    // 얕은 복사 (shallow copy)
    // spread operator(...obj) = 객체나 배열을 같은 타입에 분해하여 할당
    // 원본 객체를 바꾸지 않고 복사된 객체를 변경하고자 할 때 사용
    const copy2 = { ...obj }; // ...obj = a: 1, b: 2, c: 3 ({} 제외)
    copy2.c = 40;

    console.log("obj", obj);
    console.log("copy2", copy2);

    // obj2 address = 001
    // obj2.c address = 002
    const obj2 = { a: 1, b: 2, c: { id: 10, name: "name" } };
    const copy3 = { ...obj2 }; // address 003 = { a: 1, b: 2, c: 002 }
    copy3.a = 99;
    copy3.c.name = "judy";

    console.log("obj2", obj2);
    console.log("copy3", copy3);

    // shallow copy 때 같은 property(key)가 들어온다면 기존 property의 값을 덮어씀
    const copy4 = {
      ...obj2,
      b: 10,
      c: { ...obj2.c }, // id: 10, name: "name"
    };
    copy4.c.name = "kevin";
    console.log("copy4", copy4);

    // 객체는 순서가 없고 반복문 순회를 하지 못한다

    const obj3 = { a: 1, b: 2, c: 3, d: 4 };
    // Object.keys: 객체의 key만 배열 형태로 반환
    console.log("keys", Object.keys(obj3));
    // Object.values: 객체의 value만 배열 형태로 반환
    console.log("values", Object.values(obj3));
    // Object.entries: 객체를 [key, value] 형태의 이중 배열로 반환 (es6 이후)
    console.log("entries", Object.entries(obj3));

    // Object.assign: 타겟 객체와 그 외 객체를 합쳐서 반환 (타겟 객체의 참조 주소를 따라감)
    const target = { a: 1, b: 2 };
    const source = { c: 3, d: 4 };

    const combine = Object.assign(target, source);
    combine.a = 10;
    combine.c = 40;
    console.log("target", target);
    console.log("source", source);
    console.log("combine", combine);

    // Object.assign을 활용한 shallow copy
    const combine3 = Object.assign({}, target, source);
    combine3.a = 100;
    combine3.c = 100;
    console.log("target3", target);
    console.log("source3", source);
    console.log("combine3", combine3);

    // es6 spread 문법 이후 shallow copy
    const combine2 = {
      ...target,
      ...source,
    };
    combine2.a = 100;
    combine2.c = 100;
    console.log("target", target);
    console.log("source", source);
    console.log("combine2", combine2);

    const student = {
      className: "A",
    };

    const student1 = {
      ...student,
      name: "chris",
      age: 31,
    };
    student1.className = "B";

    const student2 = {
      ...student,
      name: "judy",
      age: 24,
    };

    console.log("student1", student1);
    console.log("student2", student2);
  </script>
</html>
